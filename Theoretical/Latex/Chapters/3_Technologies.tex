\chapter{Technologies}

The project itself was purely an idea I got as an application for AI. There would still be a need for sources to help me turn my idea into something real and applicable. The problem I had mostly with the implementation was getting the documentation of PyGame and knowing what the best implementation was for each function I wanted to implement. While making a PC game, you have to think carefully about the sources and how to use them in your favor.

\section{Running library (PyGame)}
The base for the game is made on PyGame\cite{PyGame} library. It is "a set of Python modules designed for writing video games. PyGame allows you to create fully featured games and multimedia programs in the Python language". You can also control anything in the game itself, as you would have a main loop that you can think about as the frames per second of the game. Getting to know the library was easy, because of my past experience with Python, and the documentation was easy. The library has been around for some time now, which made it easy to get a 101 guide on how to get the basics.



There was one main part while making the game, developing the GUI. Making the interface for the game was a little hard as it would take much time to learn the drawing functions, such as writing a text on the screen. During the AI training, there is information that shows on the screen to make reading the log easy, like the \textbf{score} and \textbf{generation number} along side with the \textbf{genome ID}, as in figure \ref{fig:scoreframe}. Writing the info is not as easy as dragging and dropping like most gaming engines, but everything has to be coded on the screen with x and y coordinates.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{usedImages/scoreFrame}
	\caption{Illustration for info on the score side.}
	\label{fig:scoreframe}
\end{figure}

What is good about the PyGame library is that it allows me to have dynamic game dimensions. The screen resolution for the game while developing it was $400*800$, but as most of the components on the screen are made in relation to the screen resolution the user define from the code, then you would not have to change every component location from the code, the game will already do it by itself.

\section{AI library (N.E.A.T Algorithm)}\label{sec:ai-library-neat-algorithm}
"\textbf{N}euro \textbf{E}volution of \textbf{A}ugmented \textbf{T}opologies. And this is what's known as a genetic algorithm" \cite{Python_Pong_AI_Tutorial_-_Using_NEAT}. Think of it as the way that is used in humans to learn (refer to the example of the \hyperref[sec:ai-life-example]{kid and the ball} in further reading) and the natural selection of the ones that perform well as humans and are smarter, they managed to reproduce until today. Unlike the others, who were not fortunate enough to have what it takes to survive in different scenarios.

In other words, to explain it "There is a larger category called TWEANN stands for \textbf{T}opology and \textbf{W}eight \textbf{E}volving \textbf{A}rtificial \textbf{N}eural \textbf{N}etworks" \cite{A.I_Learns_to_Play_Soni_the_Hedgehog_-_NEAT_Explained} These are algorithms that not only evolve the strength of the connection weight for a fixed network topology but actually evolves both the topology of the network and its weights." The scientists behind the N.E.A.T algorithm identified three major challenges for TWEANN:

\begin{enumerate} \label{list:3tweanns}
	\item \textbf{Meaningful crossover}: by tracking genes through historical markings.\\
	This stops the algorithm from blindly crossing over the genomes of two neural networks (NN) and creating unnormally mutated neural networks. There are two ways to progress through a user-specified number of generations, "with each generation being produced by reproduction (either sexual or asexual) and mutation of the most fit individuals of the previous generation".
	\begin{itemize}
		\item \textbf{Sexual}: means that the new generation will be made out of the best-performing genomes from \textbf{the previous generation}.
		\item \textbf{Asexual}: algorithm will \textbf{generate a random genome} to reproduce with the genomes with the highest fitness score to make the new generation.
	\end{itemize}
	
	\item \textbf{Speciation}: protecting structural innervation through speciation.\\
	That protects new structures, as they are typically low on hidden network numbers, allowing them to optimize with each other on their own. You can say category before we eliminate them. This is done by splitting up the population into several species based on the similarity of topology, connections between neurons, and their weights and biases. They only compete within their species because some of them who are not performing well at present, can perform well in the future after the right mutation with each other without the need to eliminate them now.
	\item \textbf{Structure complexity}: incrementally growing from minimal structure.\\
It prevents the algorithm from creating complex networks at the beginning of the new generation that may have to later reduce the number of nodes and connections. They did this by starting all networks with no hidden layers between the input and output layers. NN only has a series of connection genes between them, and if it is found to be useful and necessary to tweak the output a little, then it can involve complexity.
\end{enumerate}

They designed N.E.A.T to specifically address each one of the above characteristics. Point (2) and (3) will be explained more in details at the \hyperref[sec:explain-the-log]{explain the log} from timeline chapter.



